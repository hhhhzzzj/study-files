好！我直接看 MallChat 项目的实际代码，给你讲它是怎么做的。

好！现在我看懂了。让我直接告诉你 **MallChat 实际是怎么做的**：

---

# MallChat 的版本升级方式（实际操作）

### 1. 版本管理方式

MallChat 用的是 **手动 SQL 脚本 + 日期命名** 的方式：

```
docs/version/
├── 2023-06-04.sql  ← 第1次升级（新增角色表、撤回消息功能）
├── 2023-06-17.sql  ← 第2次升级（新增敏感词表）
├── 2023-07-01.sql  ← 第3次升级（插入机器人用户）
├── 2023-07-09.sql  ← 第4次升级
├── 2023-07-17.sql  ← 第5次升级
└── 2023-08-13.sql  ← 第6次升级（新增本地消息表）
```

### 2. 实际升级步骤

**假设你现在运行的是 6月4日的版本，要升级到 8月13日：**

```bash
# 第1步：备份数据库（重要！）
mysqldump -u root -p mallchat > backup_20231225.sql

# 第2步：按顺序执行 SQL 脚本
mysql -u root -p mallchat < docs/version/2023-06-17.sql
mysql -u root -p mallchat < docs/version/2023-07-01.sql
mysql -u root -p mallchat < docs/version/2023-07-09.sql
mysql -u root -p mallchat < docs/version/2023-07-17.sql
mysql -u root -p mallchat < docs/version/2023-08-13.sql

# 第3步：滚动升级服务器
# 服务器1
systemctl stop mallchat
cp mallchat-new.jar /app/mallchat.jar
systemctl start mallchat
# 等5分钟，看日志有没有报错

# 服务器2
systemctl stop mallchat
cp mallchat-new.jar /app/mallchat.jar
systemctl start mallchat
# 等5分钟

# 服务器3
systemctl stop mallchat
cp mallchat-new.jar /app/mallchat.jar
systemctl start mallchat
```

### 3. 看具体的升级内容

**2023-06-04.sql（第1次升级）**：
```sql
-- 新增了什么？
1. 新增 role 表（角色表）
2. 新增 user_role 表（用户角色关系表）
3. 修改 message 表的 type 字段（支持撤回消息）
4. 修改 message 表的 content 字段长度（1024字符）

-- 注意：都是 ADD 和 MODIFY，没有 DROP！
```

**2023-06-17.sql（第2次升级）**：
```sql
-- 新增敏感词表
CREATE TABLE `sensitive_word` (...)
INSERT INTO `sensitive_word` VALUES ('TMD');
INSERT INTO `sensitive_word` VALUES ('tmd');

-- 只是新增表，不影响旧功能
```

**2023-08-13.sql（第6次升级）**：
```sql
-- 新增本地消息表（用于消息重试）
CREATE TABLE `secure_invoke_record` (...)

-- 又是新增表，不影响旧功能
```

### 4. MallChat 的兼容性设计

**看代码实例**：

**例子1：message 表的 type 字段**
```sql
-- 旧版本：type 默认值是 NULL
-- 新版本：type 默认值是 1
alter table `message` MODIFY COLUMN `type` int(11) DEFAULT '1';
```

**Java 代码兼容**：
```java
// 旧版本的消息，type 可能是 null
if (message.getType() == null) {
    message.setType(1);  // 设置默认值
}
```

**例子2：新增字段都有默认值**
```sql
-- 新增字段时，都设置了默认值
`active_status` int(11) DEFAULT '2'  -- 默认离线
`status` int(11) DEFAULT '0'         -- 默认正常
`type` int(11) DEFAULT 1             -- 默认普通消息
```

这样旧代码不写这个字段，数据库也能正常插入。

### 5. 回滚怎么办？

**MallChat 的回滚方式**：

```bash
# 假设升级到 8月13日版本后出问题

# 第1步：回滚代码（简单）
systemctl stop mallchat
cp mallchat-old.jar /app/mallchat.jar
systemctl start mallchat

# 第2步：回滚数据库（麻烦！）
# 方案1：恢复备份
mysql -u root -p mallchat < backup_20231225.sql
# 缺点：会丢失升级后的新数据

# 方案2：手动删除新增的表
DROP TABLE IF EXISTS `secure_invoke_record`;
# 优点：不丢数据
# 缺点：要手动写 SQL

# 方案3：不回滚数据库（推荐）
# 新增的表不影响旧代码运行
# 旧代码不会用到新表，所以不用删
```

### 6. 为什么 MallChat 能这样升级？

**核心原则**：

1. **只增不删**
   - ✅ 新增表：`CREATE TABLE`
   - ✅ 新增字段：`ADD COLUMN`
   - ✅ 修改字段：`MODIFY COLUMN`（加默认值）
   - ❌ 删除表：没有 `DROP TABLE`（除了重建）
   - ❌ 删除字段：没有 `DROP COLUMN`

2. **新字段有默认值**
   ```sql
   `type` int(11) DEFAULT '1'
   `status` int(11) DEFAULT '0'
   ```
   旧代码不写这个字段，数据库自动填默认值。

3. **新功能用新表**
   - 敏感词功能 → 新增 `sensitive_word` 表
   - 消息重试功能 → 新增 `secure_invoke_record` 表
   - 不修改旧表，不影响旧功能

---

## 总结：MallChat 的实际做法

| 步骤 | 操作 | 注意事项 |
|------|------|---------|
| **1. 准备** | 写好 SQL 脚本，放到 `docs/version/` | 按日期命名 |
| **2. 备份** | `mysqldump` 备份数据库 | 必须做！ |
| **3. 升级数据库** | 按顺序执行 SQL 脚本 | 不能跳过 |
| **4. 升级代码** | 逐台替换 jar 包 | 每台等5分钟 |
| **5. 验证** | 测试功能是否正常 | 看日志 |
| **6. 回滚（如果需要）** | 恢复旧 jar 包 | 数据库一般不回滚 |

**核心思想**：
- 数据库只增不删
- 新字段有默认值
- 新功能用新表
- 代码兼容新旧数据

**这就是 MallChat 的实际升级方式！简单、实用、风险低。**

---
# --------------這裏是分割綫---------------
# -----分割綫-----
# -----分割綫-----
# -----分割綫-----
# -----分割綫-----
# -----分割綫-----
# -----分割綫----
# -----分割綫-----
# --------------這裏是分割綫---------------
---


# 分布式核心问题！

### 为什么是分布式问题？

**单体应用**：停服 → 升级 → 启动，简单粗暴
**分布式应用**：3台服务器，不能同时停，新旧版本会共存

---

## 三种升级策略

### 1. 滚动升级（最常用）

```
初始：服务器1、2、3 都是 v1.0
步骤1：升级服务器1 → v1.1（观察5分钟）
步骤2：升级服务器2 → v1.1（观察5分钟）
步骤3：升级服务器3 → v1.1（完成）

优点：零停机，风险可控
缺点：升级慢，需要版本兼容
```

### 2. 蓝绿部署

```
蓝环境：服务器1、2、3 (v1.0) ← 当前流量
绿环境：服务器4、5、6 (v1.1) ← 待机

升级：Nginx 一键切换流量到绿环境
回滚：Nginx 一键切回蓝环境

优点：切换快（秒级），回滚快
缺点：需要双倍服务器，成本高
```

### 3. 金丝雀发布（灰度）

```
第1天：5% 用户 → v1.1，95% 用户 → v1.0
第2天：50% 用户 → v1.1，50% 用户 → v1.0
第3天：100% 用户 → v1.1

优点：风险最小，出问题只影响少量用户
缺点：升级最慢
```

---

## 兼容性问题（核心！）

### 1. 数据库兼容性

**问题**：
```sql
-- v1.1 新增字段
ALTER TABLE user ADD COLUMN email VARCHAR(100);

-- v1.0 的代码不认识 email 字段，会报错
```

**解决方案**：
```
第1步：先加字段（设置默认值）
ALTER TABLE user ADD COLUMN email VARCHAR(100) DEFAULT '';

第2步：升级代码到 v1.1（可以读写 email）
第3步：观察一周，确认没问题
第4步：如果要删字段，再发一个版本 v1.2
```

**原则**：
- ✅ 可以加字段（设置默认值）
- ✅ 可以加表
- ❌ 不能删字段（旧版本会报错）
- ❌ 不能改字段类型（旧版本读不了）

### 2. 接口兼容性

**问题**：
```java
// v1.0 的接口
public User getUser(Long id) {
    return new User(id, name, age);
}

// v1.1 改了返回值
public UserVO getUser(Long id) {
    return new UserVO(id, name, age, email);  // 多了 email
}

// 问题：v1.0 的服务调用 v1.1 的接口，反序列化失败
```

**解决方案**：
```java
// 方案1：保持向后兼容（推荐）
public User getUser(Long id) {
    User user = new User(id, name, age);
    user.setEmail(email);  // 新字段可选
    return user;
}

// 方案2：版本号隔离
public User getUserV1(Long id);  // 旧接口
public UserVO getUserV2(Long id);  // 新接口

// 方案3：使用 @JsonIgnoreProperties(ignoreUnknown = true)
// 旧版本忽略不认识的字段
```

### 3. MQ 消息兼容性

**问题**：
```java
// v1.0 的消息
class LoginMessage {
    Long uid;
    Integer code;
}

// v1.1 新增字段
class LoginMessage {
    Long uid;
    Integer code;
    String deviceId;  // 新增
}

// 问题：v1.0 发送的消息没有 deviceId，v1.1 消费会报错
```

**解决方案**：
```java
// 新字段设置默认值
class LoginMessage {
    Long uid;
    Integer code;
    String deviceId = "";  // 默认值
}

// 或者判空
if (message.getDeviceId() != null) {
    // 处理 deviceId
}
```

### 4. Redis 缓存兼容性

**问题**：
```java
// v1.0 存储的数据
User user = new User(id, name, age);
redis.set("user:1", JSON.toJSONString(user));

// v1.1 读取
UserVO userVO = JSON.parseObject(redis.get("user:1"), UserVO.class);
// 报错：缺少 email 字段
```

**解决方案**：
```java
// 方案1：清空缓存（简单粗暴）
redis.del("user:*");

// 方案2：版本号隔离
redis.set("user:v2:1", JSON.toJSONString(userVO));

// 方案3：兼容读取
UserVO userVO = JSON.parseObject(redis.get("user:1"), UserVO.class);
if (userVO.getEmail() == null) {
    userVO.setEmail("");  // 设置默认值
}
```

---

## 回滚机制

### 1. 代码回滚

**滚动升级的回滚**：
```bash
# 发现 v1.1 有问题，回滚到 v1.0
服务器1：停止 v1.1 → 启动 v1.0
服务器2：停止 v1.1 → 启动 v1.0
服务器3：停止 v1.1 → 启动 v1.0

时间：5-10分钟
```

**蓝绿部署的回滚**：
```bash
# Nginx 切换流量
nginx.conf: upstream backend {
    server blue-env;  # 切回蓝环境
}

时间：秒级
```

### 2. 数据库回滚（最难！）

**问题**：
```sql
-- v1.1 新增了字段
ALTER TABLE user ADD COLUMN email VARCHAR(100);

-- 回滚到 v1.0，但数据库已经有 email 字段了
-- 删除字段会丢失数据！
```

**解决方案**：
```
原则：数据库只能前进，不能后退

方案1：不删字段，v1.0 忽略 email
方案2：如果必须删，先备份数据
方案3：使用数据库版本管理工具（Flyway/Liquibase）
```

### 3. 回滚检查清单

```
□ 代码是否可以回滚？
□ 数据库是否兼容旧版本？
□ Redis 缓存是否需要清空？
□ MQ 消息是否兼容？
□ 是否有数据丢失风险？
□ 回滚后是否需要重启服务？
```

---

## MallChat 的升级方案

### 查看版本历史

```bash
# 查看 docs/version 目录
docs/version/
├── 2023-06-04.sql  # 第1个版本
├── 2023-06-17.sql  # 第2个版本
├── 2023-07-01.sql
├── 2023-07-09.sql
├── 2023-07-17.sql
└── 2023-08-13.sql  # 最新版本
```

这些是数据库增量脚本，每次升级执行对应的 SQL。

### MallChat 的升级步骤

```bash
# 1. 备份数据库
mysqldump -u root -p mallchat > backup.sql

# 2. 执行增量 SQL
mysql -u root -p mallchat < docs/version/2023-08-13.sql

# 3. 滚动升级服务器
# 服务器1
systemctl stop mallchat
cp mallchat-v1.1.jar /app/
systemctl start mallchat
# 观察5分钟

# 服务器2
systemctl stop mallchat
cp mallchat-v1.1.jar /app/
systemctl start mallchat
# 观察5分钟

# 服务器3
systemctl stop mallchat
cp mallchat-v1.1.jar /app/
systemctl start mallchat
```

### MallChat 的兼容性设计

**1. 数据库只增不减**
```sql
-- ✅ 好的做法
ALTER TABLE user ADD COLUMN email VARCHAR(100) DEFAULT '';

-- ❌ 不好的做法
ALTER TABLE user DROP COLUMN old_field;
```

**2. MQ 消息向后兼容**
```java
// 新增字段都有默认值
class PushMessageDTO {
    List<Long> uidList;
    WSBaseResp<?> wsBaseMsg;
    Integer pushType = 1;  // 默认值
}
```

**3. Redis 使用版本号**
```java
// 不同版本用不同的 key
RedisKey.USER_TOKEN_STRING = "user:token:";  // v1.0
RedisKey.USER_INFO_STRING = "user:info:v2:";  // v2.0
```

---

## 实战案例

### 案例1：新增用户邮箱字段

**需求**：用户表新增 email 字段

**错误做法**：
```
1. 直接加字段
2. 升级代码
3. 结果：旧版本代码报错（不认识 email）
```

**正确做法**：
```
第1步：加字段（设置默认值）
ALTER TABLE user ADD COLUMN email VARCHAR(100) DEFAULT '';

第2步：升级代码（兼容 email 为空）
if (user.getEmail() == null || user.getEmail().isEmpty()) {
    user.setEmail("未设置");
}

第3步：滚动升级服务器
第4步：观察一周，确认没问题
```

### 案例2：修改消息格式

**需求**：登录消息新增设备ID

**错误做法**：
```java
// 直接改消息结构
class LoginMessage {
    Long uid;
    Integer code;
    String deviceId;  // 新增，但没有默认值
}
// 结果：旧版本发送的消息，新版本消费报错
```

**正确做法**：
```java
// 方案1：新字段可选
class LoginMessage {
    Long uid;
    Integer code;
    String deviceId;  // 可以为 null
}

// 消费时判空
if (message.getDeviceId() != null) {
    // 处理设备ID
}

// 方案2：新建消息类型
class LoginMessageV2 {
    Long uid;
    Integer code;
    String deviceId;
}
```

### 案例3：删除旧字段

**需求**：删除用户表的 old_field 字段

**正确做法**：
```
第1步（v1.1）：代码不再使用 old_field
第2步：滚动升级到 v1.1
第3步：观察1个月，确认没问题
第4步（v1.2）：删除字段
ALTER TABLE user DROP COLUMN old_field;
第5步：升级到 v1.2
```

**为什么要等1个月？**
- 确保所有服务器都升级到 v1.1
- 确保没有遗留的代码还在用这个字段
- 万一要回滚，数据还在

---

## 总结

### 核心原则

1. **向后兼容**：新版本能处理旧版本的数据
2. **向前兼容**：旧版本能处理新版本的数据（尽量）
3. **数据库只增不减**：加字段可以，删字段要慎重
4. **灰度发布**：先小范围验证，再全量
5. **快速回滚**：出问题能快速回到旧版本

### 检查清单

升级前：
- □ 数据库脚本是否向后兼容？
- □ 新字段是否有默认值？
- □ 接口是否向后兼容？
- □ MQ 消息是否兼容？
- □ Redis 缓存是否需要清空？
- □ 是否有回滚方案？

升级中：
- □ 是否逐台升级？
- □ 每台升级后是否观察？
- □ 是否监控错误日志？

升级后：
- □ 是否全量验证功能？
- □ 是否保留旧版本（以便回滚）？
- □ 是否通知用户？

---

**这就是分布式系统的版本升级和回滚！核心是兼容性设计，让新旧版本能和平共处。**