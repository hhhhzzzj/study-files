好问题！让我直接看 MallChat 的代码，看它有哪些容灾设计。

完美！现在我看懂了 MallChat 的容灾设计。让我直接告诉你：

---

## MallChat 的容灾设计（实际代码）

### 1. 消息重试机制（核心！）

**问题**：发送 MQ 消息失败怎么办？

**MallChat 的解决方案**：`@SecureInvoke` 注解 + 本地消息表

```java
// MQ 发送消息
@SecureInvoke  // ← 这个注解保证消息一定发送成功
public void sendSecureMsg(String topic, Object body, Object key) {
    Message<Object> build = MessageBuilder
        .withPayload(body)
        .setHeader(MessageConst.PROPERTY_KEYS, key)
        .build();
    rocketMQTemplate.send(topic, build);
}
```

**工作原理**：

```
第1步：调用 sendSecureMsg()
第2步：@SecureInvoke 拦截，先存到数据库
       ↓
   secure_invoke_record 表：
   {
     id: 1,
     method: "sendSecureMsg",
     args: ["topic", "body", "key"],
     status: 1,  // 待执行
     retry_times: 0,
     max_retry_times: 5
   }

第3步：事务提交后，异步执行 sendSecureMsg()
第4步：如果成功，删除记录
第5步：如果失败，更新状态，等待重试
```

**重试策略**：

```java
// 每5秒扫描一次待重试的记录
@Scheduled(cron = "*/5 * * * * ?")
public void retry() {
    List<SecureInvokeRecord> records = secureInvokeRecordDao.getWaitRetryRecords();
    for (SecureInvokeRecord record : records) {
        doAsyncInvoke(record);  // 重新执行
    }
}

// 重试时间指数增长：2分钟、4分钟、8分钟、16分钟...
private Date getNextRetryTime(Integer retryTimes) {
    double waitMinutes = Math.pow(2, retryTimes);  // 2^1=2, 2^2=4, 2^3=8...
    return DateUtil.offsetMinute(new Date(), (int) waitMinutes);
}
```

**效果**：

```
第1次失败：2分钟后重试
第2次失败：4分钟后重试
第3次失败：8分钟后重试
第4次失败：16分钟后重试
第5次失败：标记为最终失败，人工介入
```

---

### 2. 限流保护（防止服务被打垮）

**问题**：用户疯狂发消息，服务器扛不住怎么办？

**MallChat 的解决方案**：`@FrequencyControl` 注解

```java
// 发送消息接口
@PostMapping("/msg")
@FrequencyControl(time = 5, count = 3, target = FrequencyControl.Target.UID)   // 5秒内最多3条
@FrequencyControl(time = 30, count = 5, target = FrequencyControl.Target.UID)  // 30秒内最多5条
@FrequencyControl(time = 60, count = 10, target = FrequencyControl.Target.UID) // 60秒内最多10条
public ApiResult<ChatMessageResp> sendMsg(@RequestBody ChatMessageReq request) {
    // 发送消息
}
```

**工作原理**：

```
用户A 发送第1条消息：通过 ✅
用户A 发送第2条消息：通过 ✅
用户A 发送第3条消息：通过 ✅
用户A 发送第4条消息：拒绝 ❌（5秒内超过3条）

等待5秒后：
用户A 发送第5条消息：通过 ✅
```

**Redis 实现**：

```java
// Redis Key: frequency:uid:10001:5
// Redis Value: 3（已发送3条）
// 过期时间：5秒

if (redis.get("frequency:uid:10001:5") >= 3) {
    throw new FrequencyControlException("发送太快了，请稍后再试");
}
redis.incr("frequency:uid:10001:5");
redis.expire("frequency:uid:10001:5", 5);
```

---

### 3. 异步处理（避免阻塞）

**问题**：发送消息涉及多个步骤（存储、推送、通知），如果同步执行会很慢。

**MallChat 的解决方案**：线程池异步执行

```java
// 配置线程池
@Bean(ThreadPoolConfig.WS_EXECUTOR)
public ThreadPoolTaskExecutor websocketExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(16);
    executor.setMaxPoolSize(16);
    executor.setQueueCapacity(1000);  // 队列容量1000
    
    // 队列满了，直接丢弃（不重要的消息）
    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
    
    return executor;
}

// 异步推送消息
threadPoolTaskExecutor.execute(() -> {
    sendMsg(channel, wsBaseResp);
});
```

**拒绝策略**：

```
队列未满：放入队列，等待执行
队列满了：直接丢弃（DiscardPolicy）

为什么丢弃？
- WebSocket 推送不是关键业务
- 用户刷新页面就能看到最新消息
- 避免服务器被打垮
```

---

### 4. 分布式锁（避免并发问题）

**问题**：用户同时在多个设备申请好友，可能重复申请。

**MallChat 的解决方案**：`@RedissonLock` 注解

```java
@RedissonLock(key = "#uid")  // 基于用户ID加锁
public void apply(Long uid, FriendApplyReq request) {
    // 申请好友
}
```

**工作原理**：

```
用户A 在手机端申请好友：获取锁 → 执行 → 释放锁
用户A 在电脑端申请好友：等待锁 → 获取锁 → 执行 → 释放锁

结果：不会重复申请 ✅
```

---

### 5. 心跳检测（及时发现断线）

**问题**：用户网络断了，服务器怎么知道？

**MallChat 的解决方案**：Netty 心跳检测

```java
// 30秒没收到消息，关闭连接
pipeline.addLast(new IdleStateHandler(30, 0, 0));

@Override
public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
    if (evt instanceof IdleStateEvent) {
        IdleStateEvent event = (IdleStateEvent) evt;
        if (event.state() == IdleState.READER_IDLE) {
            // 30秒没收到消息，用户下线
            userOffLine(ctx);
        }
    }
}
```

**效果**：

```
用户正常：每10秒发送心跳 → 服务器收到 → 重置计时器
用户断网：30秒没收到心跳 → 服务器主动关闭连接 → 释放资源
```

---

## 紧急处理方案

### 1. Redis 挂了

**影响**：
- 无法生成 loginCode
- 无法验证 Token
- 限流失效

**紧急方案**：

```java
// 方案1：降级到本地缓存
try {
    return RedisUtils.get(key);
} catch (Exception e) {
    log.error("Redis 异常，使用本地缓存", e);
    return localCache.get(key);
}

// 方案2：跳过限流
try {
    checkFrequencyControl(uid);
} catch (Exception e) {
    log.error("限流检查失败，跳过", e);
    // 继续执行，不限流
}
```

### 2. RocketMQ 挂了

**影响**：
- 扫码登录失败
- 消息推送失败

**紧急方案**：

```java
// 方案1：本地消息表兜底
@SecureInvoke  // 消息存到数据库，MQ 恢复后自动重试
public void sendMsg(String topic, Object body) {
    rocketMQTemplate.send(topic, body);
}

// 方案2：前端轮询
// 用户扫码后，前端每2秒轮询一次
setInterval(() => {
    checkLoginStatus(loginCode);
}, 2000);
```

### 3. 数据库挂了

**影响**：
- 所有功能不可用

**紧急方案**：

```bash
# 方案1：主从切换（自动）
# 主库挂了，自动切换到从库

# 方案2：降级（手动）
# 关闭非核心功能，只保留聊天
```

### 4. 服务器挂了

**影响**：
- 部分用户无法访问

**紧急方案**：

```bash
# 方案1：Nginx 自动摘除故障节点
# 服务器1 挂了，Nginx 自动把流量转到服务器2、3

# 方案2：快速重启
systemctl restart mallchat

# 方案3：回滚到旧版本
cp mallchat-old.jar /app/mallchat.jar
systemctl restart mallchat
```

---

## 总结：MallChat 的容灾能力

| 问题 | 解决方案 | 恢复时间 |
|------|---------|---------|
| **MQ 发送失败** | @SecureInvoke 重试 | 2-16分钟 |
| **服务器被打垮** | @FrequencyControl 限流 | 实时 |
| **并发冲突** | @RedissonLock 分布式锁 | 实时 |
| **用户断线** | 心跳检测 | 30秒 |
| **Redis 挂了** | 降级到本地缓存 | 手动 |
| **RocketMQ 挂了** | 本地消息表兜底 | 自动 |
| **数据库挂了** | 主从切换 | 自动/手动 |
| **服务器挂了** | Nginx 自动摘除 | 秒级 |

**核心思想**：
1. **重试机制**：失败了自动重试，不丢消息
2. **限流保护**：防止被打垮
3. **异步处理**：不阻塞主流程
4. **降级方案**：关键服务挂了，降级到备用方案

**这就是 MallChat 的实际容灾设计！简单、实用、有效。**